/**
 * ============================================================================
 * ABYSS EXPLORER - IFS (ITERATED FUNCTION SYSTEM) SHADER
 * ============================================================================
 * 
 * GLSL shader framework for general Iterated Function Systems.
 * IFS fractals are generated by repeatedly applying a set of contractive
 * affine transformations.
 * 
 * Mathematical Background:
 * An IFS consists of N transformations T_i: R³ → R³
 * Each T_i is typically: T_i(x) = A_i * x + b_i where A_i is a 3×3 matrix
 * 
 * The attractor of the IFS is the unique compact set K such that:
 * K = ∪ T_i(K)
 * 
 * Distance Estimation for IFS:
 * We use the "escape time" method combined with orbit folding:
 * 1. Apply inverse transforms to find fundamental domain
 * 2. Track scaling through iterations
 * 3. DE = distance_to_seed / accumulated_scale
 * 
 * Implemented Fractals:
 * - Sierpinski Tetrahedron/Pyramid
 * - Sierpinski Carpet (3D)
 * - Koch Snowflake (3D)
 * - Cantor Dust
 * - Custom affine IFS
 * 
 * References:
 * - Hutchinson (1981) - Fractals and self-similarity
 * - Barnsley - "Fractals Everywhere"
 * - Knighty (fractalforums.com) - IFS distance estimation
 * - Syntopia - Fragmentarium IFS implementations
 * 
 * @module shaders/ifs.glsl
 * @author Abyss Explorer Team
 * @version 1.0.0
 */

// ============================================================================
// IFS UNIFORMS
// ============================================================================

export const IFS_UNIFORMS = /* glsl */`
// IFS specific uniforms
uniform int uIFSType;               // 0=sierpinski, 1=carpet, 2=koch, 3=cantor, 4=custom
uniform int uIFSIterations;         // Max iterations
uniform float uIFSScale;            // Base scale factor
uniform vec3 uIFSOffset;            // Translation offset

// Transform matrices (for custom IFS, up to 8 transforms)
uniform mat4 uIFSTransform0;
uniform mat4 uIFSTransform1;
uniform mat4 uIFSTransform2;
uniform mat4 uIFSTransform3;
uniform mat4 uIFSTransform4;
uniform mat4 uIFSTransform5;
uniform mat4 uIFSTransform6;
uniform mat4 uIFSTransform7;
uniform int uIFSTransformCount;     // Number of active transforms

// Blending
uniform float uIFSBlendFactor;      // For smooth blending between transforms
uniform bool uIFSSmooth;            // Enable smooth IFS

// Coloring
uniform int uIFSColorMode;          // 0=iteration, 1=transform, 2=position
uniform vec3 uIFSColorA;
uniform vec3 uIFSColorB;
uniform vec3 uIFSColorC;

// Rotation per iteration
uniform float uIFSRotation;
uniform vec3 uIFSRotAxis;
`;

// ============================================================================
// IFS DISTANCE ESTIMATOR
// ============================================================================

export const IFS_DE = /* glsl */`
/**
 * ============================================================================
 * IFS DISTANCE ESTIMATOR
 * ============================================================================
 * 
 * IFS distance estimation uses orbit folding:
 * 
 * For each iteration:
 * 1. Determine which transformation maps the point closest to origin
 * 2. Apply the inverse of that transformation
 * 3. Track the cumulative scaling
 * 
 * The DE is then: (distance to seed shape) / scale
 * 
 * For symmetric IFS (like Sierpinski), we can use reflection/folding
 * instead of explicit transforms.
 */

${IFS_UNIFORMS}

/**
 * Signed distance to tetrahedron
 * Vertices at (1,1,1), (1,-1,-1), (-1,1,-1), (-1,-1,1)
 */
float sdTetrahedron(vec3 p, float r) {
    float d = 0.0;
    d = max(d, abs(p.x + p.y) - r);
    d = max(d, abs(p.x - p.y) - r);
    d = max(d, abs(p.x + p.z) - r);
    d = max(d, abs(p.x - p.z) - r);
    d = max(d, abs(p.y + p.z) - r);
    d = max(d, abs(p.y - p.z) - r);
    return d / sqrt(3.0);
}

/**
 * Alternative tetrahedron using planes
 */
float sdTetrahedronPlanes(vec3 p) {
    // Four face planes
    const vec3 n1 = vec3(1, 1, 1);
    const vec3 n2 = vec3(1, -1, -1);
    const vec3 n3 = vec3(-1, 1, -1);
    const vec3 n4 = vec3(-1, -1, 1);
    
    float d = dot(p, normalize(n1));
    d = max(d, dot(p, normalize(n2)));
    d = max(d, dot(p, normalize(n3)));
    d = max(d, dot(p, normalize(n4)));
    
    return d - 0.5;
}

/**
 * Sierpinski Tetrahedron (Sierpinski Pyramid)
 * 
 * Construction:
 * - Start with tetrahedron
 * - Remove central octahedron
 * - Repeat for 4 corner tetrahedra
 * 
 * IFS: 4 transforms, each scaling by 0.5 and translating to a vertex
 */
vec4 sierpinskiTetrahedron(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    
    // Tetrahedron vertices (scaled)
    const vec3 v1 = vec3(1.0, 1.0, 1.0);
    const vec3 v2 = vec3(1.0, -1.0, -1.0);
    const vec3 v3 = vec3(-1.0, 1.0, -1.0);
    const vec3 v4 = vec3(-1.0, -1.0, 1.0);
    
    float trap = 1e10;
    float lastDist = 0.0;
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        // Find closest vertex
        float d1 = length(z - v1);
        float d2 = length(z - v2);
        float d3 = length(z - v3);
        float d4 = length(z - v4);
        
        float minD = min(min(d1, d2), min(d3, d4));
        lastDist = minD;
        
        // Track orbit trap
        if (minD < trap) trap = minD;
        
        // Apply transform: scale toward closest vertex
        vec3 closest;
        if (minD == d1) closest = v1;
        else if (minD == d2) closest = v2;
        else if (minD == d3) closest = v3;
        else closest = v4;
        
        z = 2.0 * z - closest;
        scale *= 2.0;
    }
    
    // Distance to tetrahedron
    float de = sdTetrahedronPlanes(z) / scale;
    
    return vec4(de, float(iterations), trap, lastDist);
}

/**
 * Sierpinski using folding (more efficient)
 * Uses reflections instead of explicit transform selection
 */
vec4 sierpinskiFolding(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    
    // Offset to center in [0, 2] cube
    z = z + vec3(1.0);
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        // Track trap
        float d = length(z);
        if (d < trap) trap = d;
        
        // Fold: if x+y < 0, reflect
        if (z.x + z.y < 0.0) z.xy = -z.yx;
        if (z.x + z.z < 0.0) z.xz = -z.zx;
        if (z.y + z.z < 0.0) z.yz = -z.zy;
        
        // Scale and translate
        z = z * 2.0 - 1.0;
        scale *= 2.0;
    }
    
    // Return to original coordinates
    z = z - vec3(1.0);
    
    float de = (length(z) - 0.5) / scale;
    
    return vec4(de, float(iterations), trap, length(z));
}

/**
 * Sierpinski Carpet in 3D (Cantor Carpet)
 * Removes center cube from each face
 */
vec4 sierpinskiCarpet(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        // Track trap
        float d = length(z);
        if (d < trap) trap = d;
        
        // Fold into first octant
        z = abs(z);
        
        // Scale up
        z = z * 3.0;
        scale *= 3.0;
        
        // Fold back: carpet removes center row/column
        z = z - 1.0;
        z = abs(z);
        z = z - 1.0;
    }
    
    // Distance to unit cube
    vec3 q = abs(z) - vec3(1.0);
    float de = (length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)) / scale;
    
    return vec4(de, float(iterations), trap, length(z));
}

/**
 * Koch Snowflake (3D approximation)
 * Uses hexagonal symmetry and scaling
 */
vec4 kochSnowflake(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    
    // 60-degree rotation for hexagonal symmetry
    const float sin60 = 0.866025;
    const float cos60 = 0.5;
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        float d = length(z);
        if (d < trap) trap = d;
        
        // Hexagonal folds (6-fold symmetry)
        z = abs(z);
        
        // Fold along 60-degree planes
        if (z.x - z.y * sin60 < 0.0) {
            z.xy = vec2(
                z.x * cos60 + z.y * sin60,
                -z.x * sin60 + z.y * cos60
            );
        }
        
        // Scale and translate
        z = z * 3.0 - 2.0;
        scale *= 3.0;
    }
    
    float de = (length(z) - 0.5) / scale;
    
    return vec4(de, float(iterations), trap, length(z));
}

/**
 * Cantor Dust (3D)
 * Removes center third from each dimension
 * Results in dust (totally disconnected set)
 */
vec4 cantorDust(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        float d = length(z);
        if (d < trap) trap = d;
        
        // Scale up by 3
        z = z * 3.0;
        scale *= 3.0;
        
        // Fold: points in center third are removed
        // Move points to [-1, 1] in each iteration
        z = sign(z) * max(abs(z) - 1.0, 0.0);
    }
    
    // Distance to small cube
    vec3 q = abs(z) - vec3(0.5);
    float de = (length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0)) / scale;
    
    return vec4(de * 0.5, float(iterations), trap, length(z));
}

/**
 * Rotation matrix helper
 */
mat3 rotMat3(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat3(
        oc * axis.x * axis.x + c,        oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,
        oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,        oc * axis.y * axis.z - axis.x * s,
        oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c
    );
}

/**
 * Custom IFS with user-defined transforms
 * Uses up to 8 affine transforms
 */
vec4 customIFS(vec3 pos, int iterations) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    int lastTransform = 0;
    
    // Pre-compute rotation matrix if needed
    mat3 rot = rotMat3(uIFSRotAxis, uIFSRotation);
    
    for (int i = 0; i < 100; i++) {
        if (i >= iterations) break;
        
        float d = length(z);
        if (d < trap) trap = d;
        
        // Apply rotation
        if (uIFSRotation != 0.0) {
            z = rot * z;
        }
        
        // Find which transform maps closest to origin
        float minD = 1e10;
        vec3 bestZ = z;
        float bestScale = 1.0;
        int bestT = 0;
        
        // Check each transform
        for (int t = 0; t < 8; t++) {
            if (t >= uIFSTransformCount) break;
            
            vec3 tz;
            float ts;
            
            // Apply inverse transform (stored in uniform)
            if (t == 0) {
                tz = (uIFSTransform0 * vec4(z, 1.0)).xyz;
                ts = length(vec3(uIFSTransform0[0][0], uIFSTransform0[1][1], uIFSTransform0[2][2]));
            } else if (t == 1) {
                tz = (uIFSTransform1 * vec4(z, 1.0)).xyz;
                ts = length(vec3(uIFSTransform1[0][0], uIFSTransform1[1][1], uIFSTransform1[2][2]));
            } else if (t == 2) {
                tz = (uIFSTransform2 * vec4(z, 1.0)).xyz;
                ts = length(vec3(uIFSTransform2[0][0], uIFSTransform2[1][1], uIFSTransform2[2][2]));
            } else if (t == 3) {
                tz = (uIFSTransform3 * vec4(z, 1.0)).xyz;
                ts = length(vec3(uIFSTransform3[0][0], uIFSTransform3[1][1], uIFSTransform3[2][2]));
            } else {
                tz = z; // Fallback
                ts = 1.0;
            }
            
            float td = length(tz);
            if (td < minD) {
                minD = td;
                bestZ = tz;
                bestScale = ts;
                bestT = t;
            }
        }
        
        z = bestZ;
        scale *= bestScale;
        lastTransform = bestT;
    }
    
    float de = (length(z) - 0.1) / scale;
    
    return vec4(de, float(lastTransform) / float(max(uIFSTransformCount, 1)), trap, length(z));
}

/**
 * Smooth IFS using weighted blending
 * Creates organic, less angular shapes
 */
vec4 smoothIFS(vec3 pos, int iterations, float blend) {
    vec3 z = pos;
    float scale = 1.0;
    float trap = 1e10;
    
    for (int i = 0; i < 50; i++) {
        if (i >= iterations) break;
        
        float d = length(z);
        if (d < trap) trap = d;
        
        // Smooth folding using smooth abs
        z = sqrt(z * z + blend);
        
        // Smooth sort
        if (z.x < z.y) z.xy = mix(z.xy, z.yx, 0.5);
        if (z.y < z.z) z.yz = mix(z.yz, z.zy, 0.5);
        if (z.x < z.y) z.xy = mix(z.xy, z.yx, 0.5);
        
        z = z * uIFSScale - uIFSOffset;
        scale *= uIFSScale;
    }
    
    float de = (length(z) - 0.5) / scale;
    
    return vec4(de, float(iterations), trap, length(z));
}

/**
 * Main distance estimator function
 */
vec4 map(vec3 pos) {
    if (uIFSType == 0) {
        return sierpinskiFolding(pos, uIFSIterations);
    } else if (uIFSType == 1) {
        return sierpinskiCarpet(pos, uIFSIterations);
    } else if (uIFSType == 2) {
        return kochSnowflake(pos, uIFSIterations);
    } else if (uIFSType == 3) {
        return cantorDust(pos, uIFSIterations);
    } else if (uIFSSmooth) {
        return smoothIFS(pos, uIFSIterations, uIFSBlendFactor);
    } else {
        return customIFS(pos, uIFSIterations);
    }
}
`;

// ============================================================================
// COMPLETE SHADER
// ============================================================================

export const IFS_FRAGMENT = /* glsl */`
precision highp float;

#define PI 3.14159265359
#define MAX_STEPS 256
#define MAX_DIST 100.0
#define MIN_DIST 0.0001

varying vec2 vUv;

// Common uniforms
uniform vec3 uCameraPos;
uniform vec3 uCameraTarget;
uniform float uFov;
uniform float uAspect;
uniform float uTime;
uniform vec2 uResolution;

// IFS uniforms
uniform int uIFSType;
uniform int uIFSIterations;
uniform float uIFSScale;
uniform vec3 uIFSOffset;
uniform mat4 uIFSTransform0;
uniform mat4 uIFSTransform1;
uniform mat4 uIFSTransform2;
uniform mat4 uIFSTransform3;
uniform mat4 uIFSTransform4;
uniform mat4 uIFSTransform5;
uniform mat4 uIFSTransform6;
uniform mat4 uIFSTransform7;
uniform int uIFSTransformCount;
uniform float uIFSBlendFactor;
uniform bool uIFSSmooth;
uniform int uIFSColorMode;
uniform vec3 uIFSColorA;
uniform vec3 uIFSColorB;
uniform vec3 uIFSColorC;
uniform float uIFSRotation;
uniform vec3 uIFSRotAxis;

// Lighting
uniform vec3 uLightDir;
uniform vec3 uLightColor;
uniform float uAmbient;
uniform float uDiffuse;
uniform float uSpecular;
uniform float uShininess;
uniform bool uShadowsEnabled;
uniform int uQuality;

${IFS_DE}

vec3 getRayDir(vec2 uv, vec3 ro, vec3 ta) {
    vec3 ww = normalize(ta - ro);
    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
    vec3 vv = normalize(cross(uu, ww));
    float fovScale = tan(uFov * 0.5);
    return normalize(uv.x * uu * fovScale * uAspect + uv.y * vv * fovScale + ww);
}

vec4 rayMarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * t;
        vec4 res = map(p);
        
        if (res.x < MIN_DIST * t) {
            return vec4(t, res.y, res.z, res.w);
        }
        
        if (t > MAX_DIST) break;
        
        t += res.x * 0.9;
    }
    
    return vec4(-1.0);
}

vec3 calcNormal(vec3 p) {
    vec2 e = vec2(0.0001, 0.0);
    return normalize(vec3(
        map(p + e.xyy).x - map(p - e.xyy).x,
        map(p + e.yxy).x - map(p - e.yxy).x,
        map(p + e.yyx).x - map(p - e.yyx).x
    ));
}

float calcShadow(vec3 ro, vec3 rd) {
    float res = 1.0;
    float t = 0.01;
    
    for (int i = 0; i < 64; i++) {
        float h = map(ro + rd * t).x;
        res = min(res, 16.0 * h / t);
        if (res < 0.001 || t > 10.0) break;
        t += clamp(h, 0.01, 0.2);
    }
    
    return clamp(res, 0.0, 1.0);
}

float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    
    for (int i = 0; i < 5; i++) {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = map(pos + h * nor).x;
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

vec3 palette(float t) {
    return uIFSColorA + uIFSColorB * cos(6.28318 * (uIFSColorC * t + vec3(0.0, 0.1, 0.2)));
}

void main() {
    vec2 uv = vUv * 2.0 - 1.0;
    
    vec3 ro = uCameraPos;
    vec3 ta = uCameraTarget;
    vec3 rd = getRayDir(uv, ro, ta);
    
    vec4 res = rayMarch(ro, rd);
    
    vec3 col;
    
    if (res.x > 0.0) {
        vec3 pos = ro + rd * res.x;
        vec3 nor = calcNormal(pos);
        
        vec3 baseCol;
        if (uIFSColorMode == 1) {
            baseCol = palette(res.y);
        } else if (uIFSColorMode == 2) {
            baseCol = 0.5 + 0.5 * nor;
        } else {
            baseCol = palette(res.z * 0.5);
        }
        
        vec3 lightDir = normalize(uLightDir);
        float diff = max(dot(nor, lightDir), 0.0);
        
        vec3 halfDir = normalize(lightDir - rd);
        float spec = pow(max(dot(nor, halfDir), 0.0), uShininess);
        
        float shadow = uShadowsEnabled ? calcShadow(pos + nor * 0.002, lightDir) : 1.0;
        float ao = calcAO(pos, nor);
        
        col = baseCol * (uAmbient + diff * uDiffuse * shadow) * ao;
        col += uSpecular * spec * shadow * uLightColor;
        
        float fog = exp(-res.x * 0.08);
        col = mix(vec3(0.03, 0.03, 0.05), col, fog);
    } else {
        col = vec3(0.02, 0.02, 0.05);
    }
    
    col = pow(col, vec3(1.0 / 2.2));
    
    gl_FragColor = vec4(col, 1.0);
}
`;

// ============================================================================
// JAVASCRIPT WRAPPER
// ============================================================================

/**
 * Create IFS shader uniforms
 */
export function createIFSUniforms(options = {}) {
    // Identity matrix for transforms
    const identity = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    ];
    
    return {
        // Camera
        uCameraPos: { value: options.cameraPos || [2, 1.5, 2] },
        uCameraTarget: { value: options.cameraTarget || [0, 0, 0] },
        uFov: { value: options.fov || Math.PI / 3 },
        uAspect: { value: options.aspect || 1 },
        uTime: { value: 0 },
        uResolution: { value: options.resolution || [1920, 1080] },
        
        // IFS specific
        uIFSType: { value: options.type || 0 },
        uIFSIterations: { value: options.iterations || 8 },
        uIFSScale: { value: options.scale || 2.0 },
        uIFSOffset: { value: options.offset || [1, 1, 1] },
        uIFSTransform0: { value: options.transform0 || identity },
        uIFSTransform1: { value: options.transform1 || identity },
        uIFSTransform2: { value: options.transform2 || identity },
        uIFSTransform3: { value: options.transform3 || identity },
        uIFSTransform4: { value: options.transform4 || identity },
        uIFSTransform5: { value: options.transform5 || identity },
        uIFSTransform6: { value: options.transform6 || identity },
        uIFSTransform7: { value: options.transform7 || identity },
        uIFSTransformCount: { value: options.transformCount || 4 },
        uIFSBlendFactor: { value: options.blendFactor || 0.01 },
        uIFSSmooth: { value: options.smooth || false },
        uIFSColorMode: { value: options.colorMode || 0 },
        uIFSColorA: { value: options.colorA || [0.5, 0.5, 0.5] },
        uIFSColorB: { value: options.colorB || [0.5, 0.5, 0.5] },
        uIFSColorC: { value: options.colorC || [1.0, 1.0, 1.0] },
        uIFSRotation: { value: options.rotation || 0 },
        uIFSRotAxis: { value: options.rotAxis || [0, 1, 0] },
        
        // Lighting
        uLightDir: { value: options.lightDir || [1, 1, 1] },
        uLightColor: { value: options.lightColor || [1, 1, 1] },
        uAmbient: { value: options.ambient || 0.25 },
        uDiffuse: { value: options.diffuse || 0.75 },
        uSpecular: { value: options.specular || 0.4 },
        uShininess: { value: options.shininess || 32 },
        uShadowsEnabled: { value: options.shadows !== false },
        uQuality: { value: options.quality || 1 }
    };
}

/**
 * IFS type constants
 */
export const IFS_TYPES = {
    SIERPINSKI: 0,
    CARPET: 1,
    KOCH: 2,
    CANTOR: 3,
    CUSTOM: 4
};

/**
 * Get IFS shader source
 */
export function getIFSShader() {
    return {
        vertex: /* glsl */`
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragment: IFS_FRAGMENT
    };
}

// ============================================================================
// EXPORTS
// ============================================================================

export default {
    uniforms: IFS_UNIFORMS,
    distanceEstimator: IFS_DE,
    fragment: IFS_FRAGMENT,
    createUniforms: createIFSUniforms,
    getShader: getIFSShader,
    types: IFS_TYPES
};
